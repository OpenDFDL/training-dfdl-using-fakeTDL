<?xml version="1.0" encoding="UTF-8"?>

<schema
  xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:fn="http://www.w3.org/2005/xpath-functions"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/"
  xmlns:fakeTDL="urn:com.owlcyberdefense.fakeTDL"
  targetNamespace="urn:com.owlcyberdefense.fakeTDL">

  <!--
  Using DFDLGeneralFormat as a basis

  Including this and using it in our format avoids the need to
  define values for 20+ properties that we just want typical default
  values for. Examples are sequenceKind="ordered", ignoreCase="no".

  DFDL requires you to be explicit about exactly what all properties
  values are. Hence, if we want default values for these 20+ properties
  we have to specify where we're getting those default values.

  For a look at all the property definitions in DFDLGeneralFormat.dfdl.xsd, go to
  https://s.apache.org/daffodil-DFDLGeneralFormat.dfdl.xsd and
  https://s.apache.org/daffodil-DFDLGeneralFormatBase.dfdl.xsd
  -->
  <include schemaLocation="/org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd" />

  <annotation>
    <appinfo source="http://www.ogf.org/dfdl/">

      <!--
      This format applies to the whole file.
      Note that we do NOT prefix the property names with "dfdl:" because this
      whole structure is a dfdl:format element already.

      The 'ref' property is what starts this off extending the
      DFDLGeneralFormat imported above.
      -->
      <dfdl:format
        ref="fakeTDL:GeneralFormat"
        representation="binary"
        binaryNumberRep="binary"
        byteOrder="bigEndian"
        lengthKind="implicit"
        lengthUnits="bytes"
        alignmentUnits="bytes"
        alignment="1"
        encoding="ascii"
        fillByte='X'
      />
    </appinfo>
  </annotation>

  <!--
   Root aka global element declaration for one fakeTDL message

   Best practice: make global element declarations be one-liners like this.
   Put the complexity in the complex type definition it uses.
   -->
  <element name="fakeTDL" type="fakeTDL:fakeTDLType" dfdl:lengthKind="explicit" dfdl:length="64"/>

  <complexType name="fakeTDLType">
    <choice dfdl:initiatedContent="yes">
      <element name="track" type="fakeTDL:trackMessageType" dfdl:initiator="T"/>
      <element name="identity" type="fakeTDL:identityMessageType" dfdl:initiator="D"/>
      <element name="ack" type="fakeTDL:ackMessageType" dfdl:initiator="A"/>
      <!--
      As of Daffodil release 3.9.0 and prior releases, if there are a large number of
      different messages in this choice, this will be inefficient as it is going to try
      one after another until it finds one where the initiator matches.

      Next lab we show an alternative to this.
      -->
    </choice>
  </complexType>

  <group name="everyMessageFields">
    <sequence>
      <element name="source" type="fakeTDL:unitNumber"/>
      <element name="sendTime" type="fakeTDL:timeOfDay"/>
    </sequence>
  </group>

  <complexType name="trackMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <group ref="fakeTDL:ackRelated"/>
      <element name="sourceLat" type="fakeTDL:latitude_degrees"/>
      <element name="sourceLon" type="fakeTDL:longitude_degrees"/>
      <element name="sourceElev" type="fakeTDL:elevation_25FeetMSL"/>
      <element name="trackNum" type="fakeTDL:unitNumber"/>
      <element name="time" type="fakeTDL:timeOfDay"/>
      <element name="lat" type="fakeTDL:latitude_degrees"/>
      <element name="lon" type="fakeTDL:longitude_degrees"/>
      <element name="elev" type="fakeTDL:elevation_25FeetMSL"/>
      <element name="pointType" type="fakeTDL:trackPointType"/>
      <element name="quality" type="fakeTDL:trackPointQuality"/>
      <element name="course" type="fakeTDL:course_integerDegrees"/>
      <element name="speed" type="fakeTDL:speed_dataMilesPerHour"/>
    </sequence>
  </complexType>

  <!--
  This is just factoring out two fields that are in both track and ident
  messages
  -->
  <group name="ackRelated">
    <sequence>
      <element name="mustAck" type="fakeTDL:mustAck"/>
      <element name="messageID" type="fakeTDL:messageID"/>
    </sequence>
  </group>

  <complexType name="identityMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <group ref="fakeTDL:ackRelated"/>
      <element name="trackNum" type="fakeTDL:unitNumber"/>
      <element name="time" type="fakeTDL:timeOfDay"/>
      <element name="iff" type="fakeTDL:IFF"/>
      <element name="cat" type="fakeTDL:category"/>
      <element name="type" type="fakeTDL:entityTypeDetail"/> <!-- 26 bytes to an including here -->
      <element name="desc" type="fakeTDL:identDescription"/> <!-- leaves 38 chars for description -->
    </sequence>
  </complexType>

  <complexType name="ackMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <!-- acks themselves don't have the "ackRelated" fields -->
      <element name="dest" type="fakeTDL:unitNumber"/>
      <!--
      our 64-byte messages have 9 bytes of common fields, then 5 more for dest field
      so we have 64-14, or 50 bytes left to put messageIDs, each of which is 4 bytes.
      so we can fit up to 12 messageIDs.
      -->
      <element name="ackID">
        <complexType>
          <sequence>
            <element name="count"
                     dfdl:outputValueCalc='{ fn:count(../item) }'>
              <simpleType>
                <restriction base="xs:unsignedShort">
                  <minInclusive value="1"/>
                  <maxInclusive value="12"/>
                </restriction>
              </simpleType>
            </element>
            <!--
            A common DFDL idiom is to have a named element representing the entire array,
            and the items of the array have a generic name like "item".
            -->
            <element name="item" type="fakeTDL:messageID"
                     minOccurs="1" maxOccurs="12"
                     dfdl:occursCountKind="expression"
                     dfdl:occursCount='{ ../count }'>
            </element>
          </sequence>
        </complexType>
      </element>
    </sequence>
  </complexType>

  <!--
  Below here are all the type definitions used by the fields above.

  In a larger schema these should probably go together in
  a separate DFDL schema file named fakeTDLFieldTypes.dfdl.xsd,
  but as this is a small example we're just putting them all
  in the same file.
  -->
  <simpleType name="messageType"
              dfdl:lengthKind="implicit">
    <restriction base="xs:string" >
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="T"/><!-- Track -->
      <enumeration value="D"/><!-- D for iDentity -->
      <enumeration value="A"/><!-- Ack -->
    </restriction>
  </simpleType>

  <simpleType name="unitNumber"
              dfdl:lengthKind="implicit">
    <restriction base="xs:string">
      <minLength value="5"/>
      <maxLength value="5"/>
      <!--
      Note that the XML Schema dialect of regular expressions
      allowed in these pattern facets
      is very minimal compared to the regular expressions allowed
      in DFDL properties like dfdl:lengthPattern.
      -->
      <pattern value="[A-Z0-9]{2}[0-9]{3}"/>
    </restriction>
  </simpleType>

  <!--
  DFDL refers to date and time related concepts collectively with the term "calendar", which
  is a convention also used by many Java libraries.
  -->
  <simpleType name="timeOfDay"
              dfdl:calendarPatternKind="explicit"
              dfdl:calendarPattern="hhmmss"
              dfdl:binaryCalendarRep="bcd"
              dfdl:lengthKind="explicit"
              dfdl:length="3">
    <restriction base="xs:time"/>
  </simpleType>

  <simpleType name="mustAck"
              dfdl:binaryBooleanFalseRep="0"
              dfdl:binaryBooleanTrueRep="1"
              dfdl:lengthKind="explicit"
              dfdl:length="1">
    <restriction base="xs:boolean"/>
  </simpleType>

  <simpleType name="messageID"
              dfdl:lengthKind="implicit">
    <restriction base="xs:unsignedInt">
      <maxInclusive value="99999"/>
    </restriction>
  </simpleType>

  <simpleType name="latitude_degrees"
              dfdl:binaryFloatRep="ieee"
              dfdl:lengthKind="implicit">
    <!--
    Note added dfdl:binaryFloatRep="ieee" which is part of
    DFDLGeneralFormat, so is in the default DFDL properties.
    However, as a way of making this simpleType self-documenting
    it is useful to repeat it here.
    -->
    <restriction base="xs:float">
      <minInclusive value="-90.0"/>
      <maxInclusive value="90.0"/>
    </restriction>
  </simpleType>

  <simpleType name="longitude_degrees"
              dfdl:binaryFloatRep="ieee"
              dfdl:lengthKind="implicit">
    <annotation><appinfo source="http://www.ogf.org/dfdl/">
      <!--
      Here is a commented-out assertion that illustrates a bad practice that
      DFDL beginners often seem to do.

      The idea is to insert dfdl:assert that enforce validity as well
      as well-formedness on the data. I.e., why bother with more parsing
      if the data is invalid?

      A dfdl:assert of dfdl:checkConstraints tells the DFDL parser to validate
      the well-formed data against the facets and, if it fails, to escalate
      that to a parse error.

      This is a bad idea for a number of reasons
      (1) you cannot use the schema to parse invalid data and study it
      (2) improper separation of concerns - applications might require use of a
          separate validator.
      (3) DFDL speculative parsing backtracks and tries other possibilities on
          parse errors. Data having invalid values is usually NOT a reason to
          backtrack and try other alternatives if the data is well-formed.

      <dfdl:assert>{ dfdl:checkConstraints(.) }</dfdl:assert>

      There are reasons to use checkConstraints, but forcing validity
      on the parse process is not one of them.
      -->
    </appinfo></annotation>
    <restriction base="xs:float">
      <minInclusive value="-180.0"/>
      <maxInclusive value="180.0"/>
    </restriction>
  </simpleType>

  <simpleType name="elevation_25FeetMSL"
              dfdl:lengthKind="implicit">
    <annotation><documentation>
      Units are 25 feet above Mean Sea Level.
    </documentation></annotation>
    <restriction base="xs:short">
      <minInclusive value="-1000"/>
      <maxInclusive value="32000"/>
    </restriction>
  </simpleType>

  <simpleType name="trackPointType" dfdl:lengthKind="implicit">
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="S"/><!-- start point -->
      <enumeration value="W"/><!-- way point -->
      <enumeration value="E"/><!-- end point -->
    </restriction>
  </simpleType>

  <simpleType name="trackPointQuality">
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="E"/><!-- estimated -->
      <enumeration value="A"/><!-- actual or observed -->
    </restriction>
  </simpleType>

  <simpleType name="course_integerDegrees"
              dfdl:lengthKind="implicit">
    <restriction base="xs:unsignedShort">
      <minInclusive value="0"/>
      <maxInclusive value="359"/>
    </restriction>
  </simpleType>

  <simpleType name="speed_dataMilesPerHour"
              dfdl:lengthKind="implicit">
    <annotation><documentation>
      Units are data-miles per hour. A data-mile is 6000 feet.
    </documentation></annotation>
    <restriction base="xs:unsignedShort">
      <maxInclusive value="2000"/>
    </restriction>
  </simpleType>

  <!--
  Below here are types for the additional fields needed by the Identity
  message
  -->

  <simpleType name="IFF"><!-- IFF = Identity Friend or Foe -->
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="U"/><!-- unknown -->
      <enumeration value="F"/><!-- friend -->
      <enumeration value="E"/><!-- enemy -->
    </restriction>
  </simpleType>

  <simpleType name="category">
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="L"/><!-- land -->
      <enumeration value="S"/><!-- sea (surface) -->
      <enumeration value="U"/><!-- sub -->
      <enumeration value="A"/><!-- air as in aircraft -->
      <enumeration value="W"/><!-- weapon such as missile or torpedo -->
    </restriction>
  </simpleType>

  <simpleType name="entityTypeDetail">
    <!--
      Note: there are other ways of doing numeric enums that require
      use of a Daffodil-specific extension (dfdlx:repType) to the DFDL v1.0 language.
      See the github DFDLSchema MIL-STD-2045 for examples of this alternative.
    -->
    <restriction base="xs:unsignedShort">
      <enumeration value="0"/> <!-- means unspecified aka "no statement" -->
      <enumeration value="1"/> <!-- some entity type -->
      <enumeration value="2"/> <!-- some other entity type -->
      <!--
      not bothering to fill in more of these until needed for examples
      -->
      <maxInclusive value="400"/><!-- values above this are unused -->
    </restriction>
  </simpleType>

  <simpleType name="identDescription"
              dfdl:textTrimKind="padChar"
              dfdl:textPadKind="padChar"
              dfdl:textStringPadCharacter="%#r00;"
              dfdl:textStringJustification="left"
              dfdl:lengthKind="explicit"
              dfdl:length="38">
    <annotation><documentation>
      Max length 38 characters. Unused characters at the end are filled with NUL.
      Allowed characters are "A-Z0-9.-_/()[]:" but must begin with A-Z or digit.
      Spaces are allowed, but cannot be leading nor trailing, and multiple spaces in a row
      are also not allowed, multiple punctuation in a row are also not allowed.
      Parenthesis and brackets should be matched properly, but there is no way to
      enforce that from a regular expression pattern.
    </documentation></annotation>
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="38"/>
      <pattern value="[A-Z0-9]{1,38}([. \-_:/][A-Z0-9()\[\]]{1,38}){0,38}"/>
    </restriction>
  </simpleType>


</schema>

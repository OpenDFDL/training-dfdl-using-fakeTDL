<?xml version="1.0" encoding="UTF-8"?>

<schema
  xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:fn="http://www.w3.org/2005/xpath-functions"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/"
  xmlns:fakeTDL="urn:com.owlcyberdefense.fakeTDL"
  targetNamespace="urn:com.owlcyberdefense.fakeTDL">

  <include schemaLocation="/org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd" />

  <annotation>
    <appinfo source="http://www.ogf.org/dfdl/">

      <dfdl:format
        ref="fakeTDL:GeneralFormat"
        representation="binary"
        binaryNumberRep="binary"
        byteOrder="bigEndian"
        lengthKind="implicit"
        lengthUnits="bytes"
        alignmentUnits="bytes"
        alignment="1"
        encoding="ascii"
        fillByte='X'
      />
    </appinfo>
  </annotation>

  <!--
   Root aka global element declaration for one fakeTDL message

   Best practice: make global element declarations be one-liners like this.
   Put the complexity in the complex type definition it uses.
   -->
  <element name="fakeTDL" type="fakeTDL:fakeTDLType" dfdl:lengthKind="explicit" dfdl:length="64"/>

  <!--
  In order to test whole files of messages at once, we add this element.
  -->
  <element name="fakeTDLFile">
    <complexType>
      <sequence>
        <element name="fakeTDL" type="fakeTDL:fakeTDLType" dfdl:lengthKind="explicit" dfdl:length="64"
                 minOccurs="1" maxOccurs="100" dfdl:occursCountKind="implicit">
          <annotation><appinfo source="http://www.ogf.org/dfdl/">
            <!--
            Exercise: First run test_file_bad_01 without this discriminator. Then add the discriminator.

            This discriminator controls the point of uncertainty (PoU) of the variable length array.

            Because the dfdl:occursCountKind is 'implicit', the DFDL parser speculates forward
            at this PoU because it does not know if there is another occurrence of the array or not.

            This discriminator peeks at the data stream without consuming any data
            using a regular expression pattern. If
            it matches, then the discriminator is true. If there is no match, the discriminator is false.

            If false, the PoU is resolved as the speculation failed, and there is no additional fakeTDL
            element.

            If true, the PoU is resolved as the speculation is correct, and the parse now must succeed
            to parse another fakeTDL element. This PoU is ended.

            If the parse succeeds, then the parser will face another PoU about the next possible occurrence.
            (up until the number of occurrences equals maxOccurs)

            If the parse fails, then it is parse error, and as there is no PoU, the error propagates, and
            in this case the entire parse will fail since there is no enclosing PoU.

            This discriminator means: if there is at least 1 more byte of data, then there must be
            another whole fakeTDL message.
            -->
            <!--
            <dfdl:discriminator testKind="pattern" testPattern="."/>
            -->
          </appinfo></annotation>
        </element>
      </sequence>
    </complexType>
  </element>

  <complexType name="fakeTDLType">
    <sequence>
      <!--
      We now need a messageType field. This replaces the initiators from before with
      an explicit field to hold the message type.
      -->
      <element name="messageType" type="fakeTDL:messageType"/>
      <choice dfdl:choiceDispatchKey="{ messageType }">
        <element name="track" type="fakeTDL:trackMessageType" dfdl:choiceBranchKey="T"/>
        <element name="identity" type="fakeTDL:identityMessageType" dfdl:choiceBranchKey="D"/>
        <element name="ack" type="fakeTDL:ackMessageType" dfdl:choiceBranchKey="A"/>
        <!--
        dfdl:choiceDispatchKey selects the branch with the matching dfdl:choiceBranchKey
        in constant time (using a hash table lookup). It avoids any point of uncertainty
        in the parsing.

        So this is the technique to use if there are a large number of message types.
        -->
      </choice>
    </sequence>
  </complexType>

  <group name="everyMessageFields">
    <sequence>
      <element name="source" type="fakeTDL:unitNumber"/>
      <element name="sendTime" type="fakeTDL:timeOfDay"/>
    </sequence>
  </group>

  <complexType name="trackMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <group ref="fakeTDL:ackRelated"/>
      <element name="sourceLat" type="fakeTDL:latitude_degrees"/>
      <element name="sourceLon" type="fakeTDL:longitude_degrees"/>
      <element name="sourceElev" type="fakeTDL:elevation_25FeetMSL"/>
      <element name="trackNum" type="fakeTDL:unitNumber"/>
      <element name="time" type="fakeTDL:timeOfDay"/>
      <element name="lat" type="fakeTDL:latitude_degrees"/>
      <element name="lon" type="fakeTDL:longitude_degrees"/>
      <element name="elev" type="fakeTDL:elevation_25FeetMSL"/>
      <element name="pointType" type="fakeTDL:trackPointType"/>
      <element name="quality" type="fakeTDL:trackPointQuality"/>
      <element name="course" type="fakeTDL:course_integerDegrees"/>
      <element name="speed" type="fakeTDL:speed_dataMilesPerHour"/>
    </sequence>
  </complexType>

  <!--
  This is just factoring out two fields that are in both track and ident
  messages
  -->
  <group name="ackRelated">
    <sequence>
      <element name="mustAck" type="fakeTDL:mustAck"/>
      <element name="messageID" type="fakeTDL:messageID"/>
    </sequence>
  </group>

  <complexType name="identityMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <group ref="fakeTDL:ackRelated"/>
      <element name="trackNum" type="fakeTDL:unitNumber"/>
      <element name="time" type="fakeTDL:timeOfDay"/>
      <element name="iff" type="fakeTDL:IFF"/>
      <element name="cat" type="fakeTDL:category"/>
      <element name="type" type="fakeTDL:entityTypeDetail"/> <!-- 26 bytes to an including here -->
      <element name="desc" type="fakeTDL:identDescription"/> <!-- leaves 38 chars for description -->
    </sequence>
  </complexType>

  <complexType name="ackMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <!-- acks themselves don't have the "ackRelated" fields -->
      <element name="dest" type="fakeTDL:unitNumber"/>
      <!--
      our 64-byte messages have 9 bytes of common fields, then 5 more for dest field
      so we have 64-14, or 50 bytes left to put messageIDs, each of which is 4 bytes.
      so we can fit up to 12 messageIDs.
      -->
      <element name="ackID">
        <complexType>
          <sequence>
            <element name="count"
                     dfdl:outputValueCalc='{ fn:count(../item) }'>
              <simpleType>
                <restriction base="xs:unsignedShort">
                  <minInclusive value="1"/>
                  <maxInclusive value="12"/>
                </restriction>
              </simpleType>
            </element>
            <!--
            A common DFDL idiom is to have a named element representing the entire array,
            and the items of the array have a generic name like "item".
            -->
            <element name="item" type="fakeTDL:messageID"
                     minOccurs="1" maxOccurs="12"
                     dfdl:occursCountKind="expression"
                     dfdl:occursCount='{ ../count }'>
            </element>
          </sequence>
        </complexType>
      </element>
    </sequence>
  </complexType>

  <!--
  Below here are all the type definitions used by the fields above.

  In a larger schema these should probably go together in
  a separate DFDL schema file named fakeTDLFieldTypes.dfdl.xsd,
  but as this is a small example we're just putting them all
  in the same file.
  -->
  <simpleType name="messageType"
              dfdl:lengthKind="implicit">
    <restriction base="xs:string" >
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="T"/><!-- Track -->
      <enumeration value="D"/><!-- D for iDentity -->
      <enumeration value="A"/><!-- Ack -->
    </restriction>
  </simpleType>

  <simpleType name="unitNumber"
              dfdl:lengthKind="implicit">
    <restriction base="xs:string">
      <minLength value="5"/>
      <maxLength value="5"/>
      <!--
      Note that the XML Schema dialect of regular expressions
      allowed in these pattern facets
      is very minimal compared to the regular expressions allowed
      in DFDL properties like dfdl:lengthPattern.
      -->
      <pattern value="[A-Z0-9]{2}[0-9]{3}"/>
    </restriction>
  </simpleType>

  <!--
  DFDL refers to date and time related concepts collectively with the term "calendar", which
  is a convention also used by many Java libraries.
  -->
  <simpleType name="timeOfDay"
              dfdl:calendarPatternKind="explicit"
              dfdl:calendarPattern="hhmmss"
              dfdl:binaryCalendarRep="bcd"
              dfdl:lengthKind="explicit"
              dfdl:length="3">
    <restriction base="xs:time"/>
  </simpleType>

  <simpleType name="mustAck"
              dfdl:binaryBooleanFalseRep="0"
              dfdl:binaryBooleanTrueRep="1"
              dfdl:lengthKind="explicit"
              dfdl:length="1">
    <restriction base="xs:boolean"/>
  </simpleType>

  <simpleType name="messageID"
              dfdl:lengthKind="implicit">
    <restriction base="xs:unsignedInt">
      <maxInclusive value="99999"/>
    </restriction>
  </simpleType>

  <simpleType name="latitude_degrees"
              dfdl:binaryFloatRep="ieee"
              dfdl:lengthKind="implicit">
    <!--
    Note added dfdl:binaryFloatRep="ieee" which is part of
    DFDLGeneralFormat, so is in the default DFDL properties.
    However, as a way of making this simpleType self-documenting
    it is useful to repeat it here.
    -->
    <restriction base="xs:float">
      <minInclusive value="-90.0"/>
      <maxInclusive value="90.0"/>
    </restriction>
  </simpleType>

  <simpleType name="longitude_degrees"
              dfdl:binaryFloatRep="ieee"
              dfdl:lengthKind="implicit">
    <annotation><appinfo source="http://www.ogf.org/dfdl/">
      <!--
      Here is a commented-out assertion that illustrates a bad practice that
      DFDL beginners often seem to do.

      The idea is to insert dfdl:assert that enforce validity as well
      as well-formedness on the data. I.e., why bother with more parsing
      if the data is invalid?

      A dfdl:assert of dfdl:checkConstraints tells the DFDL parser to validate
      the well-formed data against the facets and, if it fails, to escalate
      that to a parse error.

      This is a bad idea for a number of reasons
      (1) you cannot use the schema to parse invalid data and study it
      (2) improper separation of concerns - applications might require use of a
          separate validator.
      (3) DFDL speculative parsing backtracks and tries other possibilities on
          parse errors. Data having invalid values is usually NOT a reason to
          backtrack and try other alternatives if the data is well-formed.

      <dfdl:assert>{ dfdl:checkConstraints(.) }</dfdl:assert>

      There are reasons to use checkConstraints, but forcing validity
      on the parse process is not one of them.
      -->
    </appinfo></annotation>
    <restriction base="xs:float">
      <minInclusive value="-180.0"/>
      <maxInclusive value="180.0"/>
    </restriction>
  </simpleType>

  <simpleType name="elevation_25FeetMSL"
              dfdl:lengthKind="implicit">
    <annotation><documentation>
      Units are 25 feet above Mean Sea Level.
    </documentation></annotation>
    <restriction base="xs:short">
      <minInclusive value="-1000"/>
      <maxInclusive value="32000"/>
    </restriction>
  </simpleType>

  <simpleType name="trackPointType" dfdl:lengthKind="implicit">
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="S"/><!-- start point -->
      <enumeration value="W"/><!-- way point -->
      <enumeration value="E"/><!-- end point -->
    </restriction>
  </simpleType>

  <simpleType name="trackPointQuality">
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="E"/><!-- estimated -->
      <enumeration value="A"/><!-- actual or observed -->
    </restriction>
  </simpleType>

  <simpleType name="course_integerDegrees"
              dfdl:lengthKind="implicit">
    <restriction base="xs:unsignedShort">
      <minInclusive value="0"/>
      <maxInclusive value="359"/>
    </restriction>
  </simpleType>

  <simpleType name="speed_dataMilesPerHour"
              dfdl:lengthKind="implicit">
    <annotation><documentation>
      Units are data-miles per hour. A data-mile is 6000 feet.
    </documentation></annotation>
    <restriction base="xs:unsignedShort">
      <maxInclusive value="2000"/>
    </restriction>
  </simpleType>

  <!--
  Below here are types for the additional fields needed by the Identity
  message
  -->

  <simpleType name="IFF"><!-- IFF = Identity Friend or Foe -->
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="U"/><!-- unknown -->
      <enumeration value="F"/><!-- friend -->
      <enumeration value="E"/><!-- enemy -->
    </restriction>
  </simpleType>

  <simpleType name="category">
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="1"/>
      <enumeration value="L"/><!-- land -->
      <enumeration value="S"/><!-- sea (surface) -->
      <enumeration value="U"/><!-- sub -->
      <enumeration value="A"/><!-- air as in aircraft -->
      <enumeration value="W"/><!-- weapon such as missile or torpedo -->
    </restriction>
  </simpleType>

  <simpleType name="entityTypeDetail">
    <!--
      Note: there are other ways of doing numeric enums that require
      use of a Daffodil-specific extension (dfdlx:repType) to the DFDL v1.0 language.
      See the github DFDLSchema MIL-STD-2045 for examples of this alternative.
    -->
    <restriction base="xs:unsignedShort">
      <enumeration value="0"/> <!-- means unspecified aka "no statement" -->
      <enumeration value="1"/> <!-- some entity type -->
      <enumeration value="2"/> <!-- some other entity type -->
      <!--
      not bothering to fill in more of these until needed for examples
      -->
      <maxInclusive value="400"/><!-- values above this are unused -->
    </restriction>
  </simpleType>

  <simpleType name="identDescription"
              dfdl:textTrimKind="padChar"
              dfdl:textPadKind="padChar"
              dfdl:textStringPadCharacter="%#r00;"
              dfdl:lengthKind="explicit"
              dfdl:length="38">
    <annotation><documentation>
      Max length 38 characters. Unused characters at the end are filled with NUL.
      Allowed characters are "A-Z0-9.-_/()[]:" but must begin with A-Z or digit.
      Spaces are allowed, but cannot be leading nor trailing, and multiple spaces in a row
      are also not allowed, multiple punctuation in a row are also not allowed.
      Parenthesis and brackets should be matched properly, but there is no way to
      enforce that from a regular expression pattern.
    </documentation></annotation>
    <restriction base="xs:string">
      <minLength value="1"/>
      <maxLength value="38"/>
      <pattern value="[A-Z0-9]{1,38}([. \-_:/][A-Z0-9()\[\]]{1,38}){0,38}"/>
    </restriction>
  </simpleType>


</schema>

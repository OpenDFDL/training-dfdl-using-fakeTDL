<?xml version="1.0" encoding="UTF-8"?>

<schema
  xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:fn="http://www.w3.org/2005/xpath-functions"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/"
  xmlns:fakeTDL="urn:com.owlcyberdefense.fakeTDL"
  targetNamespace="urn:com.owlcyberdefense.fakeTDL">

  <include schemaLocation="fakeTDL-base.dfdl.xsd" />
  <include schemaLocation="fakeTDL-field-types.dfdl.xsd"/>

  <annotation>
    <appinfo source="http://www.ogf.org/dfdl/">

      <dfdl:format  ref="fakeTDL:baseFormat" />

    </appinfo>
  </annotation>

  <complexType name="fakeTDLType">
    <choice dfdl:initiatedContent="yes">
      <element name="track" type="fakeTDL:trackMessageType" dfdl:initiator="T"/>
      <element name="identity" type="fakeTDL:identityMessageType" dfdl:initiator="D"/>
      <element name="ack" type="fakeTDL:ackMessageType" dfdl:initiator="A"/>
      <!--
      As of Daffodil release 3.10.0 and prior releases, if there are a large number of
      different messages in this choice, this will be inefficient as it is going to try
      one after another until it finds one where the initiator matches.

      If you'd like to see a constant time technique that works today in Daffodil
      for a large number of message types, look at the way the message type dispatch
      works in the DFDLSchemas fakeTDL project on github.

      For purposes of this training lab we'll just keep this simple and use dfdl:initiatedContent="yes"
        -->
    </choice>
  </complexType>

  <group name="everyMessageFields">
    <sequence>
      <element name="source" type="fakeTDL:unitNumber"/>
      <element name="sendTime" type="fakeTDL:timeOfDay"/>
    </sequence>
  </group>

  <complexType name="trackMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <group ref="fakeTDL:ackRelated"/>
      <element name="sourceLat" type="fakeTDL:latitude_degrees"/>
      <element name="sourceLon" type="fakeTDL:longitude_degrees"/>
      <element name="sourceElev" type="fakeTDL:elevation_25FeetMSL"/>
      <element name="trackNum" type="fakeTDL:unitNumber"/>
      <element name="time" type="fakeTDL:timeOfDay"/>
      <element name="lat" type="fakeTDL:latitude_degrees"/>
      <element name="lon" type="fakeTDL:longitude_degrees"/>
      <element name="elev" type="fakeTDL:elevation_25FeetMSL"/>
      <element name="pointType" type="fakeTDL:trackPointType"/>
      <element name="quality" type="fakeTDL:trackPointQuality"/>
      <element name="course" type="fakeTDL:course_integerDegrees"/>
      <element name="speed" type="fakeTDL:speed_dataMilesPerHour"/>
    </sequence>
  </complexType>

  <!--
  This is just factoring out fields that are in both track and ident
  messages
  -->
  <group name="ackRelated">
    <sequence>
      <element name="mustAck" type="fakeTDL:mustAck"/>
      <element name="messageID" type="fakeTDL:messageID"/>
    </sequence>
  </group>

  <complexType name="identityMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <group ref="fakeTDL:ackRelated"/>
      <element name="trackNum" type="fakeTDL:unitNumber"/>
      <element name="time" type="fakeTDL:timeOfDay"/>
      <element name="iff" type="fakeTDL:IFF"/>
      <element name="cat" type="fakeTDL:category"/>
      <element name="type" type="fakeTDL:entityTypeDetail"/> <!-- 26 bytes to an including here -->
      <element name="desc" type="fakeTDL:identDescription"/> <!-- leaves 38 chars for description -->
    </sequence>
  </complexType>

  <complexType name="ackMessageType">
    <sequence>
      <group ref="fakeTDL:everyMessageFields"/>
      <!-- acks themselves don't have the "ackRelated" fields -->
      <element name="dest" type="fakeTDL:unitNumber"/>
      <!--
      our 64-byte messages have 9 bytes of common fields, then 5 more for dest field
      so we have 64-14, or 50 bytes left to put messageIDs, each of which is 4 bytes.
      so we can fit up to 12 messageIDs.
      -->
      <element name="ackID">
        <complexType>
          <sequence>
            <element name="count"
                     dfdl:outputValueCalc='{ fn:count(../item) }'>
              <simpleType>
                <restriction base="xs:unsignedShort">
                  <minInclusive value="1"/>
                  <maxInclusive value="12"/>
                </restriction>
              </simpleType>
            </element>
            <!--
            A common DFDL idiom is to have a named element representing the entire array,
            and the items of the array have a generic name like "item".
            -->
            <element name="item" type="fakeTDL:messageID"
                     minOccurs="1" maxOccurs="12"
                     dfdl:occursCountKind="expression"
                     dfdl:occursCount='{ ../count }'>
            </element>
          </sequence>
        </complexType>
      </element>
    </sequence>
  </complexType>

</schema>
